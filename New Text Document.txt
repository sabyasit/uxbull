
env.localModelPath = '/assets/models';
env.allowRemoteModels = false;

"@xenova/transformers": "^2.17.2",

import { Component, OnInit } from '@angular/core';
import { pipeline } from '@xenova/transformers';

interface SimilarityResult {
    text: string;
    score: number;
}

@Component({
    selector: 'app-string-similarity',
    templateUrl: './string-similarity.component.html',
    styleUrls: ['./string-similarity.component.css']
})
export class StringSimilarityComponent implements OnInit {
    sourceText: string = 'apple pie\napple juice\ncherry tart\nchocolate cake\nstrawberry ice cream\ncar engine\ntruck tire';
    searchText: string = 'fruit dessert';
    results: SimilarityResult[] = [];
    isLoading: boolean = false;
    statusMessage: string = '';

    extractor: any = null; // Type as any to avoid strict type issues for now, or use Pipeline if types available

    constructor() { }

    async ngOnInit() {
        this.statusMessage = 'Loading model... this may take a while initially.';
        this.isLoading = true;
        try {
            // Load the feature extraction pipeline
            this.extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
            this.statusMessage = 'Model loaded. Ready.';
        } catch (error) {
            console.error('Error loading model:', error);
            this.statusMessage = 'Error loading model. Check console.';
        } finally {
            this.isLoading = false;
        }
    }

    async search() {
        if (!this.extractor) {
            this.statusMessage = 'Model not loaded yet.';
            return;
        }

        if (!this.sourceText.trim() || !this.searchText.trim()) {
            return;
        }

        this.isLoading = true;
        this.statusMessage = 'Computing embeddings...';
        this.results = [];

        try {
            const candidates = this.sourceText.split('\n').filter(line => line.trim() !== '');

            // Get embedding for the search query
            const queryOutput = await this.extractor(this.searchText, { pooling: 'mean', normalize: true });
            const queryEmbedding = queryOutput.data;

            const scoredCandidates: SimilarityResult[] = [];

            // Get embeddings for candidates and calculate cosine similarity
            // Note: For large lists, this should be batched. For this demo, we do one by one or small batch.
            // pipeline handles batching if we pass an array, often faster.
            const candidateOutput = await this.extractor(candidates, { pooling: 'mean', normalize: true });

            // candidateOutput.data is a flattened float32array if multiple inputs
            // Check shape: [batch_size, hidden_size]
            const hiddenSize = queryOutput.dims[1];

            for (let i = 0; i < candidates.length; i++) {
                const candidateEmbedding = candidateOutput[i].data; // Access via index if the output allows, or slice raw data

                // transformers.js output for batch might be a Tensor where .data is the flat array.
                // But pipeline() with array input usually returns an array of Tensors or a batched Tensor?
                // Let's verify behavior. standard behavior for feature-extraction with array is array of Tensors.

                // Actually, let's play safe and check type, or use the Tensor methods.
                // Assuming cosine similarity on normalized vectors is just dot product.

                const score = this.cosineSimilarity(queryEmbedding, candidateEmbedding);
                scoredCandidates.push({ text: candidates[i], score });
            }

            this.results = scoredCandidates.sort((a, b) => b.score - a.score);
            this.statusMessage = 'Done.';

        } catch (error) {
            console.error('Error during search:', error);
            this.statusMessage = 'Error during search.';
        } finally {
            this.isLoading = false;
        }
    }

    cosineSimilarity(a: Float32Array | number[], b: Float32Array | number[]): number {
        let dotProduct = 0;
        for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
        }
        // Since we requested { normalize: true }, the vectors are already unit vectors.
        // So cosine similarity is just the dot product.
        return dotProduct;
    }
}

